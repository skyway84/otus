# Дроздов Юрий.
# Домашнее задание к занятию 23.


Задача:
В БД создана структура, описывающая товары (таблица goods) и продажи (таблица sales).
Есть запрос для генерации отчета – сумма продаж по каждому товару.
БД была денормализована, создана таблица (витрина), структура которой повторяет структуру отчета.
Создать триггер на таблице продаж, для поддержки данных в витрине в актуальном состоянии (вычисляющий при каждой продаже сумму и записывающий её в витрину)
Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE

#Исходные данные
CREATE SCHEMA pract_functions;

SET search_path = pract_functions, publ

-- товары:
CREATE TABLE goods
(
    goods_id    integer PRIMARY KEY,
    good_name   varchar(63) NOT NULL,
    good_price  numeric(12, 2) NOT NULL CHECK (good_price > 0.0)
);
INSERT INTO goods (goods_id, good_name, good_price)
VALUES 	(1, 'Спички хозайственные', .50),
		(2, 'Автомобиль Ferrari FXX K', 185000000.01);

-- Продажи
CREATE TABLE sales
(
    sales_id    integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    good_id     integer REFERENCES goods (goods_id),
    sales_time  timestamp with time zone DEFAULT now(),
    sales_qty   integer CHECK (sales_qty > 0)
);

INSERT INTO sales (good_id, sales_qty) VALUES (1, 10), (1, 1), (1, 120), (2, 1);

-- отчет:
SELECT G.good_name, sum(G.good_price * S.sales_qty)
FROM goods G
INNER JOIN sales S ON S.good_id = G.goods_id
GROUP BY G.good_name;

-- с увеличением объёма данных отчет стал создаваться медленно
-- Принято решение денормализовать БД, создать таблицу
CREATE TABLE good_sum_mart
(
	good_name   varchar(63) NOT NULL,
	sum_sale	numeric(16, 2)NOT NULL
);

-- Создать триггер (на таблице sales) для поддержки.
-- Подсказка: не забыть, что кроме INSERT есть еще UPDATE и DELETE

-- Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?
-- Подсказка: В реальной жизни возможны изменения цен.




#Триггерная функция
```
Логика работы: в случае совершения продажи товара, изменения позиции продажи или возврата товара запись из "витрины" для этого товара удаляется и заново пересчитывается.
Алгоритм ветвления применил потому, что при разных операциях над строкой используются разные переменные "NEW" и "OLD".
Принял решение, что триггер будет отрабатывать после совершения операции над каждой строкой таблицы sales.
```

CREATE OR REPLACE FUNCTION good_summary_update() RETURNS TRIGGER
AS $good_summary_update$
    BEGIN
```
В случае удаления продажи из таблицы sales я использую старый id
```
IF TG_OP = 'DELETE' THEN
	   DELETE FROM good_sum_mart WHERE good_name = (SELECT G.good_name FROM goods G WHERE G.goods_id = OLD.good_id);
	
       WITH nm AS (SELECT G.good_name FROM goods G WHERE G.goods_id = OLD.good_id),
       sm_sl AS (SELECT sum(G.good_price * S.sales_qty) FROM goods G INNER JOIN sales S ON S.good_id = G.goods_id WHERE S.good_id = OLD.good_id AND G.goods_id = OLD.good_id)
       INSERT INTO good_sum_mart (good_name, sum_sale)(SELECT * FROM nm, sm_sl);
	   
ELSE
       DELETE FROM good_sum_mart WHERE good_name = (SELECT G.good_name FROM goods G WHERE G.goods_id = NEW.good_id);
        
       WITH nm AS (SELECT G.good_name FROM goods G WHERE G.goods_id = NEW.good_id),
       sm_sl AS (SELECT sum(G.good_price * S.sales_qty) FROM goods G INNER JOIN sales S ON S.good_id = G.goods_id WHERE S.good_id = NEW.good_id AND G.goods_id = NEW.good_id)
	   INSERT INTO good_sum_mart (good_name, sum_sale)(SELECT * FROM nm, sm_sl);
END IF;
	   
	RETURN NULL;
    END;

$good_summary_update$ LANGUAGE plpgsql;

#Триггер
CREATE TRIGGER good_summary_update
AFTER INSERT OR UPDATE OR DELETE ON sales
    FOR EACH ROW EXECUTE FUNCTION good_summary_update();

```
Данный алгоритм неоптимален для большого количества продаж. Но такая схема позволяет в любой момент времени иметь актуальную статистику продаж.
```
